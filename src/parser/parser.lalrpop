use std::str::FromStr;
use ast::*;
use parser::utils;

#[LALR]
grammar;

pub identifier: Id = {
    Id => Id::from_str(&<>),
    r"_([a-zA-Z][a-zA-Z0-9_]+)" => Id::from_str(&<>[1..]),
};

pub scoped_name: ScopedName = {
    <identifier> => ScopedName::Qualified(vec![<>]),
    "::" <identifier> => ScopedName::FileScope(vec![<>]),
    <sn:scoped_name> "::" <id:identifier> => { let mut sn = sn; sn.push(id); sn }
};

pub const_expr: ConstExpr = {
    <or_expr> => <>,
};

pub or_expr: ConstExpr = {
    <xor_expr> => <>,
    <or_expr> "|" <xor_expr> => ConstExpr::binop(ConstExpr::Or, <>),
};

pub xor_expr: ConstExpr = {
    <and_expr> => <>,
    <xor_expr> "^" <and_expr> => ConstExpr::binop(ConstExpr::Xor, <>),
};

pub and_expr: ConstExpr = {
    <shift_expr> => <>,
    <and_expr> "&" <shift_expr> => ConstExpr::binop(ConstExpr::And, <>),
};

pub shift_expr: ConstExpr = {
    <add_expr> => <>,
    <shift_expr> ">>" <add_expr> => ConstExpr::binop(ConstExpr::Shr, <>),
    <shift_expr> "<<" <add_expr> => ConstExpr::binop(ConstExpr::Shl, <>),
};

pub add_expr: ConstExpr = {
    <mult_expr> => <>,
    <add_expr> "+" <mult_expr> => ConstExpr::binop(ConstExpr::Add, <>),
    <add_expr> "-" <mult_expr> => ConstExpr::binop(ConstExpr::Sub, <>),
};

pub mult_expr: ConstExpr = {
    <unary_expr> => <>,
    <mult_expr> "*" <unary_expr> => ConstExpr::binop(ConstExpr::Mult, <>),
    <mult_expr> "/" <unary_expr> => ConstExpr::binop(ConstExpr::Div, <>),
    <mult_expr> "%" <unary_expr> => ConstExpr::binop(ConstExpr::Mod, <>),
};

pub unary_expr: ConstExpr = {
    "-" <primary_expr> => ConstExpr::Negate(Box::new(<>)),
    "+" <primary_expr> => <>,
    "~" <primary_expr> => ConstExpr::Complement(Box::new(<>)),
    <primary_expr> => <>,
};

pub primary_expr: ConstExpr = {
    <scoped_name> => ConstExpr::ScopedName(<>),
    <literal> => ConstExpr::Literal(<>),
    "(" <const_expr> ")" => <>,
};

pub literal: Literal = {
    integer_literal,
    floating_pt_literal,
    fixed_pt_literal,
    character_literal,
    wide_character_literal,
    boolean_literal,
    string_literal,
    wide_string_literal,
};

pub integer_literal: Literal = {
    r"[1-9][[:digit:]]*" => Literal::Int(
        u64::from_str_radix(&<>, 10).unwrap()
    ),
    r"0[[:digit:]]*" => Literal::Int(
        u64::from_str_radix(&<>, 8).unwrap()
    ),
    r"0x([[:xdigit:]]+)" => Literal::Int(
        u64::from_str_radix(&<>[2..], 16).unwrap()
    ),
};

// we don't support long doubles
pub floating_pt_literal: Literal = {
    // integer and fraction parts present
    r"[[:digit:]]+\.[[:digit:]]+([eE][\-0-9][[:digit:]]*)?" => Literal::FloatPt(
        f64::from_str(&<>).unwrap()
    ),
    // integer part missing
    r"\.[[:digit:]]+([eE][\-0-9][[:digit:]]*)?" => Literal::FloatPt(
        f64::from_str(&<>).unwrap()
    ),
    // fraction part missing
    r"[[:digit:]]+\.([eE][\-0-9][[:digit:]]*)?" => Literal::FloatPt(
        f64::from_str(&<>).unwrap()
    ),
    // decimal point missing, so exponent non-optional
    r"[[:digit:]]+([eE][\-0-9][[:digit:]]*)" => Literal::FloatPt(
        f64::from_str(&<>).unwrap()
    ),
};

// we don't support fixed points, but can turn them into a string for
// error reporting
pub fixed_pt_literal: Literal = {
    // integer and fraction parts present
    r"[[:digit:]]+\.[[:digit:]]+[dD]" => Literal::FixedPt(
        String::from(<>)
    ),
    // integer part missing
    r"\.[[:digit:]]+[dD]" => Literal::FixedPt(
        String::from(<>)
    ),
    // fraction part missing
    r"[[:digit:]]+\.[dD]" => Literal::FixedPt(
        String::from(<>)
    ),
    // decimal point missing
    r"[[:digit:]]+[dD]" => Literal::FixedPt(
        String::from(<>)
    ),
};

pub character_literal: Literal = {
    // graphical characters in ISO-8859-1 postprocessed for escape sequences
    r"'[\PC&&[\x{00}-\x{FF}]]+'" => utils::parse_character_literal(<>)
};

pub wide_character_literal: Literal = {
    // graphical characters postprocessed for escape sequences
    r"L'\PC+'" => utils::parse_wide_character_literal(<>)
};

pub boolean_literal: Literal = {
    "FALSE" => Literal::Bool(false),
    "TRUE" => Literal::Bool(true),
};

pub string_literal: Literal = {
    <v:one_string_literal+> => {
        let s = v.iter().fold(String::new(), |mut acc, s| { acc.push_str(s); acc });
        Literal::String(s)
    }
};

pub one_string_literal: String = {
    // graphical characters in ISO-8859-1, minus unescaped double
    // quotes, postprocessed for escape sequences
    r#""(\\"|[\PC&&[\x{00}-\x{FF}]&&[^"]])*""# => utils::parse_one_string_literal(<>),
};

pub wide_string_literal: Literal = {
    <v:one_wide_string_literal+> => {
        let s = v.iter().fold(String::new(), |mut acc, s| { acc.push_str(s); acc });
        Literal::WString(s)
    }
};

pub one_wide_string_literal: String = {
    // graphical characters minus unescaped double quotes,
    // postprocessed for escape sequences
    r#"L"(\\"|[\PC&&[^"]])*""# => utils::parse_one_wide_string_literal(<>),
};

match {
    r"_([a-zA-Z][a-zA-Z0-9_]+)",
} else {
    "abstract",
    "any",
    "alias",
    "attribute",
    "bitfield",
    "bitmask",
    "bitset",
    "boolean",
    "case",
    "char",
    "component",
    "connector",
    "const",
    "consumes",
    "context",
    "custom",
    "default",
    "double",
    "exception",
    "emits",
    "enum",
    "eventtype",
    "factory",
    "FALSE",
    "finder",
    "fixed",
    "float",
    "getraises",
    "home",
    "import",
    "in",
    "inout",
    "interface",
    "local",
    "long",
    "manages",
    "map",
    "mirrorport",
    "module",
    "multiple",
    "native",
    "Object",
    "octet",
    "oneway",
    "out",
    "primarykey",
    "private",
    "port",
    "porttype",
    "provides",
    "public",
    "publishes",
    "raises",
    "readonly",
    "setraises",
    "sequence",
    "short",
    "string",
    "struct",
    "supports",
    "switch",
    "TRUE",
    "truncatable",
    "typedef",
    "typeid",
    "typename",
    "typeprefix",
    "unsigned",
    "union",
    "uses",
    "ValueBase",
    "valuetype",
    "void",
    "wchar",
    "wstring",
} else {
    r"(?i)abstract",
    r"(?i)any",
    r"(?i)alias",
    r"(?i)attribute",
    r"(?i)bitfield",
    r"(?i)bitmask",
    r"(?i)bitset",
    r"(?i)boolean",
    r"(?i)case",
    r"(?i)char",
    r"(?i)component",
    r"(?i)connector",
    r"(?i)const",
    r"(?i)consumes",
    r"(?i)context",
    r"(?i)custom",
    r"(?i)default",
    r"(?i)double",
    r"(?i)exception",
    r"(?i)emits",
    r"(?i)enum",
    r"(?i)eventtype",
    r"(?i)factory",
    r"(?i)FALSE",
    r"(?i)finder",
    r"(?i)fixed",
    r"(?i)float",
    r"(?i)getraises",
    r"(?i)home",
    r"(?i)import",
    r"(?i)in",
    r"(?i)inout",
    r"(?i)interface",
    r"(?i)local",
    r"(?i)long",
    r"(?i)manages",
    r"(?i)map",
    r"(?i)mirrorport",
    r"(?i)module",
    r"(?i)multiple",
    r"(?i)native",
    r"(?i)Object",
    r"(?i)octet",
    r"(?i)oneway",
    r"(?i)out",
    r"(?i)primarykey",
    r"(?i)private",
    r"(?i)port",
    r"(?i)porttype",
    r"(?i)provides",
    r"(?i)public",
    r"(?i)publishes",
    r"(?i)raises",
    r"(?i)readonly",
    r"(?i)setraises",
    r"(?i)sequence",
    r"(?i)short",
    r"(?i)string",
    r"(?i)struct",
    r"(?i)supports",
    r"(?i)switch",
    r"(?i)TRUE",
    r"(?i)truncatable",
    r"(?i)typedef",
    r"(?i)typeid",
    r"(?i)typename",
    r"(?i)typeprefix",
    r"(?i)unsigned",
    r"(?i)union",
    r"(?i)uses",
    r"(?i)ValueBase",
    r"(?i)valuetype",
    r"(?i)void",
    r"(?i)wchar",
    r"(?i)wstring",
} else {
    r"[a-zA-Z][a-zA-Z0-9_]+" => Id,
    _
}
